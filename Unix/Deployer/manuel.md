# Déployer sur Unix
>On présume ici que le projet à été cloné et que les dépendances sont installées sur notre espace serveur.

## 1.Diriger le trafic entrant:

Nginx est le serveur du VPS qui reçois tout le trafic entrant, en gros toutes les requêtes sont envoyées à l'adresse IP publique du serveur.  
Sa configuration par défaut se situe dans 'etc/nginx/sites-enabled/default'.
Nginx peut sur un même serveur gérer le trafic entrant/sortant de plusieurs sites.  
Pour ce faire on crée un fichier de configuration par site dans le répertoire "/sites-available/", on s'y rend et on le crée comme suit :

	sudo touch mon_site

Une fois le fichier crée il faut ajouter le lien symbolique dans le répertoire "/sites-enabled/" grâce à la commande 'ln' suivante:
>Attention le chemin doit partir de la racine.

	sudo ln -s /etc/nginx/sites-available/mon_site /etc/nginx/sites-enabled 

Une fois le fichier et le lien crées, ne pas oublier de relancer le serveur pour qu'il prenne en compte les modifications:

	sudo service nginx reload

Maintenant il est temps de configurer notre fichier mon_site fraichement crée  
Dailleurs voici à quoi ressemble le fichier par defaut de nginx dans "/sites-enabled/":

	##
	# You should look at the following URL's in order to grasp a solid understanding
	# of Nginx configuration files in order to fully unleash the power of Nginx.
	# https://www.nginx.com/resources/wiki/start/
	# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
	# https://wiki.debian.org/Nginx/DirectoryStructure
	#
	# In most cases, administrators will remove this file from sites-enabled/ and
	# leave it as reference inside of sites-available where it will continue to be
	# updated by the nginx packaging team.
	#
	# This file will automatically load configuration files provided by other
	# applications, such as Drupal or Wordpress. These applications will be made
	# available underneath a path with that package name, such as /drupal8.
	#
	# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
	##

	# Default server configuration
	#
	server {
		listen 80 default_server;
		listen [::]:80 default_server;

		# SSL configuration
		#
		# listen 443 ssl default_server;
		# listen [::]:443 ssl default_server;
		#
		# Note: You should disable gzip for SSL traffic.
		# See: https://bugs.debian.org/773332
		#
		# Read up on ssl_ciphers to ensure a secure configuration.
		# See: https://bugs.debian.org/765782
		#
		# Self signed certs generated by the ssl-cert package
		# Don't use them in a production server!
		#
		# include snippets/snakeoil.conf;

		root /var/www/html;

		# Add index.php to the list if you are using PHP
		index index.html index.htm index.nginx-debian.html;

		server_name _;

		location / {
			# First attempt to serve request as file, then
			# as directory, then fall back to displaying a 404.
			try_files $uri $uri/ =404;
		}

		# pass PHP scripts to FastCGI server
		#
		#location ~ \.php$ {
		#       include snippets/fastcgi-php.conf;
		#
		#       # With php-fpm (or other unix sockets):
		#       fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
		#       # With php-cgi (or other tcp sockets):
		#       fastcgi_pass 127.0.0.1:9000;
		#}

		# deny access to .htaccess files, if Apache's document root
		# concurs with nginx's one
		#
		#location ~ /\.ht {
		#       deny all;
		#}
	}

Voila le contenu que doit avoir notre fichier de configuration mon_site:

	#Virtual Host configuration for mon_site.com

	#You can move that to a different file under sites-available/ and symlink that
	#to sites-enabled/ to enable it.

	server {
		listen 80;
		listen [::]:80;
		server_name mon_site.com 92.222.167.113;
		root /home/ubuntu/mon_site/;
		location /static {
			alias /home/ubuntu/mon_site/staticfiles/;
		}

		location / {
			proxy_set_header Host $http_host;
			proxy_set_header X-Forwarder-For $proxy_add_x_forwarder_for;
			proxy_redirect off;
			proxy_pass http://127.0.0.1:8000;
		}
	}

### explications:  
`listen 80;` veut dire que nginx écoute à ce port car toutes les requêtes HTTP qui entrent sur notre VPS y arrivent.  
`server_name mon_site.com 92.222.167.113;` veut dire qu'il cible toutes les requêtes dont le nom d'hôte est mon_site.com et si il ne les trouve pas il utilise le numero du serveur dans ce cas ci.  
`root /home/ubuntu/mon_site/;` indique la racine du projet dans lequel les fichiers seront demandé. Ainsi tout les autres demande de fichier suivront ce chemin de manière relative.  
`proxy_set_header` réecrit les headers de la requête HTTP.  
`X-Forwarder-For` transmet l'adresse IP du client qui a fait la requête originale.  
Ces lignes sont nécessaires à Django par exemple.  
`proxy_pass http://127.0.0.1:8000` donne l'adresse finale au port duquel notre application tourne quand tout se passe bien.  

Il est important après chaque modification de relancer nginx qu'il prenne bien en compte les informations:  

	sudo service nginx reload

## 2.Servir du script Python:

Nginx ne peut pas interpreter le Python il faut donc qu'il dialogue avec un serveur qui en est capable : Gunicorn.  
Ce serveur (fait pour les projets Python déployés sur Unix) utilise les spécifications WSGI (Web Server Gateway Interface).  
Il est déjà dans le framework Django nativement par exemple.  
On peut le démarrer en tapant la commande :

	gunicorn mon_projet.wsgi:application

Evidement cela marche mais n'est pas viable, si l'appli s'arrête pour X raisons qui la relance ?  
Il est clair que le mieux serai de trouver un middleware fait pour ce genre de tâche.  

## 3.Automatiser le process

Comme dit précédement il serai plus judicieux de trouver un programme  qui va se charger de lancer ou relancer après un arrêt notre appli fraîchement déploiée, car on a autre chose à foutre, si les applis s'accumulent on va quand même pas passer la journée à relancer tout à la main ! Et c'est la qu'entre en jeux Supervisor. Chaque fichier situés dans "etc/supervisors/conf.d" est un processus à surveiller.  
On s'y rend donc et en créeont donc un nouveau:  

	cd etc/supervisors/conf.d
	sudo touch mon_site-gunicorn.conf

Une fois ouvert voilà à quoi il doit ressembler:

	[program:mon_site]
	user=ubuntu
	directory=/home/ubuntu/mon_site
	environment=ENV="production",SECRET_KEY="tartenpion62caca848pipi"
	command=/home/ubuntu/mon_site/env/bin/gunicorn project.wsgi:application
	autostart=true
	autorestart=true
	startsecs=0
	stderr_logfile=/var/log/urvcard.log

### explications:  
`[program:mon_site]` ça c'est le nom du programme pour Supervisor lorsque l'on fait nos commandes.  
`user=ubuntu` it can be someone else if we want.  
`directory=/home/ubuntu/mon_site` la racine du projet.  
`environment=ENV="production",SECRET_KEY="tartenpion62caca848pipi"` on peut indiquer le user et sa clé si il y en a un, juste il faut que ce soit raccord avec le user.  
`command=/home/ubuntu/mon_site/env/bin/gunicorn project.wsgi:application` le path complet suivis de la commande à éxecuter. On peux lancer aussi du python comme suit => `command=/home/ubuntu/mon_site/env/bin/python3 mon_module.py`.  
`autostart=true` on lui dit de se lancer tout seul.  
`autorestart=true` on lui dit relance toi tout seul si l'appli s'est arrêtée.  
`startsecs=0` on peut determiner le temps d'éxecution d'un programme, 0 veut dire sans limite de temps.  
`stderr_logfile=/var/log/mon_site.log`  le fichier dans lequel se trouvera tout nos log à cette destination.  

Une fois rédigé Supervisor va le lancer directement. Il est dailleurs possible de voir le process grâce à la commande :

	sudo supervisorctl status

Il faut garder à l'esprit qu'après chaque réecriture du fichier il est nécessaire d'avertir Supervisor tout comme on le fait aussi avec Nginx par les deux commandes suivantes: 

	sudo supervisorctl reread
	sudo supervisorctl reload
